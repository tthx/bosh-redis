---
name: redis

templates:
  keys/ca.crt.erb: keys/ca.crt
  keys/ca.key.erb: keys/ca.key
  config/redis.conf.erb: config/redis.conf
  config/users.acl.erb: config/users.acl
  bin/pre-start.erb: bin/pre-start
  bin/post-deploy.erb: bin/post-deploy
  bin/redis_ctl.erb: bin/redis_ctl

packages:
- redis

provides:
- name: redis_conn
  type: conn
  properties:
# General
  - bind
  - port
  - password
  - admin_user
  - admin_password
  - exporter_user
  - exporter_password
# Memory management
  - maxmemory
  - maxmemory_policy
  - maxmemory_samples
  - replica_ignore_maxmemory
  - active_expire_effort
  - lfu_log_factor
  - lfu_decay_time
# TLS/SSL
  - tls
  - tls_port
  - tls_ca_certificate
  - tls_ca_private_key
  - tls_auth_clients
  - tls_replication
  - tls_cluster
  - tls_protocols
  - tls_ciphers
  - tls_ciphersuites
  - tls_prefer_server_ciphers
# Persistence
  - save
  - appendonly
# Replication
  - replication
  - replica_user
  - replica_password
  - min_replicas_to_write
  - min_replicas_max_lag
# Sentinel
  - sentinel_user
  - sentinel_password
  - max_detected_failures
  - down_after_milliseconds
  - parallel_syncs
  - failover_timeout
# Cluster
  - cluster_enabled
  - cluster_replicas_per_node
  - cluster_node_timeout

consumes:
- name: redis_conn
  type: conn
- name: slave_conn
  type: conn
  optional: true
- name: redis_sentinel_conn
  type: sentinel_conn
  optional: true
- name: sentinel_slave_conn
  type: sentinel_conn
  optional: true

properties:
################################## NETWORK #####################################
  bind:
    default: false
    description: |
      Specify this property to "true" if you would like the bind address of a given instance to be automatically set to its assigned static IP. Otherwise, Redis listens only on "localhost".
  port:
    default: "6379"
    description: |
      Accept connections on the specified port, default is 6379 (IANA #815344). If port 0 is specified Redis will not listen on a TCP socket. If TLS is used, port is set to 0. See TLS/SSL section below.
  tcp_backlog:
    default: "511"
    description: |
      In high requests-per-second environments you need an high backlog in order
      to avoid slow clients connections issues. Note that the Linux kernel
      will silently truncate it to the value of /proc/sys/net/core/somaxconn so
      make sure to raise both the value of somaxconn and tcp_max_syn_backlog
      in order to get the desired effect.
  timeout:
    default: "0"
    description: |
      Close the connection after a client is idle for N seconds (0 to disable).
  tcp_keepalive:
    default: "300"
    description: |
      TCP keepalive. If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication. A reasonable value for this option is 300 seconds, which is the new Redis default starting with Redis 3.2.1.
################################# TLS/SSL #####################################
  tls:
    default: false
    description: |
      To enable/disable TLS/SSL.
  tls_port:
    default: "6379"
    description: |
      The TLS/SSL port to use.
  tls_keys_dir:
    default: "/var/vcap/jobs/redis/keys"
    description: |
      The directory where TLS keys are stored.
  tls_ca_certificate:
    description: |
      Authority certificate for TLS connection.
  tls_ca_private_key:
    description: |
      Authority private key for TLS connection.
  tls_ca_cert_file:
    default: "ca.crt"
    description: |
      Certificate authority's certificate file name.
  tls_ca_key_file:
    default: "ca.key"
    description: |
      Certificate authority's private key file name.
  tls_key_length:
    default: "2048"
    description: |
      Private key length for TLS connection.
  tls_cert_duration:
    default: "365"
    description: |
      Certificate duration for TLS connection.
  tls_cert_file:
    default: "redis.crt"
    description: |
      Configure a X.509 certificate and private key to use for authenticating the server to connected clients, masters or cluster peers. These files should be PEM formatted.
  tls_key_file:
    default: "redis.key"
    description: |
      See tls_cert_file.
  tls_dh_params_file:
    default: "redis.dh"
    description: |
      Configure a DH parameters file to enable Diffie-Hellman (DH) key exchange.
  tls_dh_length:
    default: 2048
    description: |
      Length of DH parameters.
  tls_ca_cert_dir:
    default: "/var/vcap/packages/redis/ca"
    description: |
      See tls_ca_cert_file.
  tls_auth_clients:
    default: true
    description: |
      By default, clients (including replica servers) on a TLS port are required to authenticate using valid client side certificates. It is possible to disable authentication by setting tls_auth_clients to false.
  tls_replication:
    default: false
    description: |
      By default, a Redis replica does not attempt to establish a TLS connection
      with its master. Set this property to true to enable TLS on replication links.
  tls_cluster:
    default: false
    description: |
      By default, the Redis Cluster bus uses a plain TCP connection. To enable
      TLS for the bus protocol, set this property to true.
  tls_protocols:
    description: |
      Explicitly specify TLS versions to support. Allowed values are case insensitive and include "TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3" (OpenSSL >= 1.1.1) or any combination. To enable only TLSv1.2 and TLSv1.3, use: "TLSv1.2 TLSv1.3".
  tls_ciphers:
    description: |
      Configure allowed ciphers.  See the ciphers(1ssl) manpage for more information about the syntax of this string.
      Note: this configuration applies only to <= TLSv1.2.
  tls_ciphersuites:
    description: |
      Configure allowed TLSv1.3 ciphersuites.  See the ciphers(1ssl) manpage for more information about the syntax of this string, and specifically for TLSv1.3 ciphersuites.
  tls_prefer_server_ciphers:
    default: false
    description: |
      When choosing a cipher, use the server's preference instead of the client
      preference. By default, the server follows the client's preference.
  tls_session_caching:
    default: true
    description: |
      By default, TLS session caching is enabled to allow faster and less expensive reconnections by clients that support it. Set this property to false to disable caching.
  tls_session_cache_size:
    default: "20480"
    description: |
      Change the default number of TLS sessions cached. A zero value sets the cache to unlimited size. The default size is 20480.
  tls_session_cache_timeout:
    default: "300"
    description: |
      Change the default timeout of cached TLS sessions. The default timeout is 300 seconds.
################################# GENERAL #####################################
  run_dir:
    default: "/var/vcap/sys/run/redis"
    description: |
      Directory where to store Redis pid file.
  pidfile:
    default: "redis.pid"
    description: |
      If a pid file is specified, Redis writes it where specified at startup and removes it at exit.
      When the server runs non daemonized, no pid file is created if none is specified in the configuration. When the server is daemonized, the pid file is used even if not specified, defaulting to "/var/run/redis.pid".
      Creating a pid file is best effort: if Redis is not able to create it nothing bad happens, the server will start and run normally.
  loglevel:
    default: "notice"
    description: |
      Specify the server verbosity level.
      This can be one of:
        - "debug" (a lot of information, useful for development/testing),
        - "verbose" (many rarely useful info, but not a mess like the debug level),
        - "notice" (moderately verbose, what you want in production probably),
        - "warning" (only very important / critical messages are logged).
  log_dir:
    default: "/var/vcap/sys/log/redis"
    description: |
      Directory where to store Redis log file.
  logfile:
    default: "redis.log"
    description: |
      Specify the log file name. Also the empty string can be used to force Redis to log on the standard output. Note that if you use standard output for logging but daemonize, logs will be sent to /dev/null.
  syslog_enabled:
    default: "yes"
    description: |
      To enable logging to the system logger, just set syslog-enabled to yes, and optionally update the other syslog parameters to suit your needs.
  syslog_ident:
    default: "redis-server"
    description: |
      Specify the syslog identity.
  syslog_facility:
    default: "local0"
    description: |
      Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
  databases:
    default: "16"
    description: |
      Set the number of databases. The default database is DB 0, you can select a different one on a per-connection basis using SELECT <dbid> where dbid is a number between 0 and <databases>-1.
################################ SNAPSHOTTING  ################################
  save:
    default: ""
    description: |
      Save the DB on disk:
        save <seconds> <changes>
      Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred.
      In the following example:
        save 900 1
        save 300 10
        save 60 10000
      the behaviour will be to save:
        - after 900 sec (15 min) if at least 1 key changed
        - after 300 sec (5 min) if at least 10 keys changed
        - after 60 sec if at least 10000 keys changed
      Note: you can disable saving completely by commenting out all "save" lines.
      It is also possible to remove all the previously configured save points by adding a save directive with a single empty string argument like in the following example:
        save ""
  stop_writes_on_bgsave_error:
    default: "yes"
    description: |
      By default Redis will stop accepting writes if RDB snapshots are enabled (at least one save point) and the latest background save failed. This will make the user aware (in a hard way) that data is not persisting on disk properly, otherwise chances are that no one will notice and some disaster will happen. However if you have setup your proper monitoring of the Redis server and persistence, you may want to disable this feature so that Redis will continue to work as usual even if there are problems with disk, permissions, and so forth.
  rdbcompression:
    default: "yes"
    description: |
      Compress string objects using LZF when dump .rdb databases.
  rdbchecksum:
    default: "yes"
    description: |
      Since version 5 of RDB a CRC64 checksum is placed at the end of the file. This makes the format more resistant to corruption but there is a performance hit to pay (around 10%) when saving and loading RDB files, so you can disable it for maximum performances.
  rdb_del_sync_files:
    default: "no"
    description: |
      Remove RDB files used by replication in instances without persistence
      enabled. By default this option is disabled, however there are environments
      where for regulations or other security concerns, RDB files persisted on
      disk by masters in order to feed replicas, or stored on disk by replicas
      in order to load them for the initial synchronization, should be deleted
      ASAP. Note that this option ONLY WORKS in instances that have both AOF
      and RDB persistence disabled, otherwise is completely ignored.
      
      An alternative (and sometimes better) way to obtain the same effect is
      to use diskless replication on both master and replicas instances. However
      in the case of replicas, diskless is not always an option.
  dir:
    default: "/var/vcap/store/redis"
    description: |
      The working directory. The DB will be written inside this directory. The Append Only File will also be created inside this directory.
################################# REPLICATION #################################
  replication:
    default: false
    description: |
      When set to false, master/slave replication will be disabled and all instances will run as standalone deployments.
  replica_serve_stale_data:
    default: "yes"
    description: |
      When a replica loses its connection with the master, or when the replication is still in progress, the replica can act in two different ways:
        1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
           still reply to client requests, possibly with out of date data, or the
           data set may just be empty if this is the first synchronization.
        2) if replica-serve-stale-data is set to 'no' the replica will reply with
           an error "SYNC with master in progress" to all the kind of commands
           but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
           SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
           COMMAND, POST, HOST: and LATENCY.
  replica_read_only:
    default: "yes"
    description: |
      You can configure a replica instance to accept writes or not. Writing against a replica instance may be useful to store some ephemeral data (because data written on a replica will be easily deleted after resync with the master) but may also cause problems if clients are writing to it because of a misconfiguration.
      Since Redis 2.6 by default replicas are read-only.
      Note: read only replicas are not designed to be exposed to untrusted clients on the internet. It's just a protection layer against misuse of the instance. Still a read only replica exports by default all the administrative commands such as CONFIG, DEBUG, and so forth. To a limited extent you can improve security of read only replicas using 'rename-command' to shadow all the administrative / dangerous commands.
  repl_diskless_sync_delay:
    default: "5"
    description: |
      When diskless replication is enabled, it is possible to configure the delay
      the server waits in order to spawn the child that transfers the RDB via socket
      to the replicas.

      This is important since once the transfer starts, it is not possible to serve
      new replicas arriving, that will be queued for the next RDB transfer, so the server
      aits a delay in order to let more replicas arrive.

      The delay is specified in seconds, and by default is 5 seconds. To disable
      it entirely just set it to 0 seconds and the transfer will start ASAP.
  repl_diskless_load:
    default: "disabled"
    description: |
      Replica can load the RDB it reads from the replication link directly from the socket, or store the RDB to a file and read that file after it was completely recived from the master.

      In many cases the disk is slower than the network, and storing and loading
      the RDB file may increase replication time (and even increase the master's
      Copy on Write memory and salve buffers).
      However, parsing the RDB file directly from the socket may mean that we have
      to flush the contents of the current database before the full rdb was
      received. For this reason we have the following options:

      "disabled"    - Don't use diskless load (store the rdb file to the disk
                      first)
      "on-empty-db" - Use diskless load only when it is completely safe.
      "swapdb"      - Keep a copy of the current db contents in RAM while parsing
                      the data directly from the socket. note that this requires
                      sufficient memory, if you don't have it, you risk an OOM kill.
  repl_ping_replica_period:
    default: "10"
    description: |
      Replicas send PINGs to server in a predefined interval. It is possible to change this interval with the repl_ping_replica_period option. The default value is 10 seconds.
  repl_timeout:
    default: "60"
    description: |
      The following option sets the replication timeout for:
        1) Bulk transfer I/O during SYNC, from the point of view of replica.
        2) Master timeout from the point of view of replicas (data, pings).
        3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
      It is important to make sure that this value is greater than the value specified for repl-ping-replica-period otherwise a timeout will be detected every time there is low traffic between the master and the replica.
  repl_disable_tcp_nodelay:
    default: "no"
    description: |
      Disable TCP_NODELAY on the replica socket after SYNC?
      If you select "yes" Redis will use a smaller number of TCP packets and less bandwidth to send data to replicas. But this can add a delay for the data to appear on the replica side, up to 40 milliseconds with Linux kernels using a default configuration.
      If you select "no" the delay for data to appear on the replica side will be reduced but more bandwidth will be used for replication.
      By default we optimize for low latency, but in very high traffic conditions or when the master and replicas are many hops away, turning this to "yes" may be a good idea.
  repl_backlog_size:
    default: "1mb"
    description: |
      Set the replication backlog size. The backlog is a buffer that accumulates
      replica data when replicas are disconnected for some time, so that when a replica
      wants to reconnect again, often a full resync is not needed, but a partial
      resync is enough, just passing the portion of data the replica missed while
      disconnected.

      The bigger the replication backlog, the longer the time the replica can be
      disconnected and later be able to perform a partial resynchronization.

      The backlog is only allocated once there is at least a replica connected.
  repl_backlog_ttl:
    default: "3600"
    description: |
      After a master has no longer connected replicas for some time, the backlog
      will be freed. The following option configures the amount of seconds that
      need to elapse, starting from the time the last replica disconnected, for
      the backlog buffer to be freed.

      Note that replicas never free the backlog for timeout, since they may be
      promoted to masters later, and should be able to correctly "partially
      resynchronize" with the replicas: hence they should always accumulate backlog.

      A value of 0 means to never release the backlog.
  replica_priority:
    default: "100"
    description: |
      The replica priority is an integer number published by Redis in the INFO output.
      It is used by Redis Sentinel in order to select a replica to promote into a master if the master is no longer working correctly.
      A replica with a low priority number is considered better for promotion, so for instance if there are three replicas with priority 10, 100, 25 Sentinel will pick the one with priority 10, that is the lowest.
      However a special priority of 0 marks the replica as not able to perform the role of master, so a replica with priority of 0 will never be selected by Redis Sentinel for promotion.
      By default the priority is 100.
  min_replicas_to_write:
    default: "0"
    description: |
      It is possible for a master to stop accepting writes if there are less than N replicas connected, having a lag less or equal than M seconds.
      The N replicas need to be in "online" state.
      The lag in seconds, that must be <= the specified value, is calculated from the last ping received from the replica, that is usually sent every second.
      This option does not GUARANTEE that N replicas will accept the write, but will limit the window of exposure for lost writes in case not enough replicas are available, to the specified number of seconds.
      For example to require at least 3 replicas with a lag <= 10 seconds use:
        min-replicas-to-write 3
        min-replicas-max-lag 10
      Setting one or the other to 0 disables the feature.
      By default min-replicas-to-write is set to 0 (feature disabled) and min-replicas-max-lag is set to 10.
      If min_replicas_to_write is greater than the number of Redis slaves, this feature is disabled.
  min_replicas_max_lag:
    default: "10"
    description: |
      See previous "min_replicas_to_write".
  replica_announce:
    default: false
    description: |
      When port forwarding or Network Address Translation (NAT) is used, the replica may be actually reachable via different IP and port pairs. The option can be used by a replica in order to report to its master a specific set of IP and port, so that both INFO and ROLE will report those values.
################################# SENTINEL MONITORING ###########################
  max_detected_failures:
    default: "2"
    description: |      
      The max_detected_failures is the number of Sentinels that need to agree about the fact the master is not reachable, in order to really mark the master as failing, and eventually start a failover procedure if possible.
      However the max_detected_failures is only used to detect the failure. In order to actually perform a failover, one of the Sentinels need to be elected leader for the failover and be authorized to proceed. This only happens with the vote of the majority of the Sentinel processes.
  down_after_milliseconds:
    default: "30000"
    description: |
      Number of milliseconds the master (or any attached replica or sentinel) should be unreachable (as in, not acceptable reply to PING, continuously, for the specified period) in order to consider it in S_DOWN state (Subjectively Down).
  parallel_syncs:
    default: "1"
    description: "How many replicas we can reconfigure to point to the new replica simultaneously during the failover. Use a low number if you use the replicas to serve query to avoid that all the replicas will be unreachable at about the same time while performing the synchronization with the master."
  failover_timeout:
    default: "180000"
    description: |
      Specifies the failover timeout in milliseconds. It is used in many ways:
        - The time needed to re-start a failover after a previous failover was already tried against the same master by a given Sentinel, is two times the failover timeout.
        - The time needed for a replica replicating to a wrong master according to a Sentinel current configuration, to be forced to replicate with the right master, is exactly the failover timeout (counting since the moment a Sentinel detected the misconfiguration).
        - The time needed to cancel a failover that is already in progress but did not produced any configuration change (SLAVEOF NO ONE yet not acknowledged by the promoted replica).
        - The maximum time a failover in progress waits for all the replicas to be reconfigured as replicas of the new master. However even after this time the replicas will be reconfigured by the Sentinels anyway, but not with the exact parallel-syncs progression as specified.
      Default is 3 minutes.
############################### KEYS TRACKING #################################
  tracking_table_max_keys:
    default: "1000000"
    description: |
      Redis implements server assisted support for client side caching of values.
      This is implemented using an invalidation table that remembers, using
      16 millions of slots, what clients may have certain subsets of keys. In turn
      this is used in order to send invalidation messages to clients. Please
      to understand more about the feature check this page:

        https://redis.io/topics/client-side-caching

      When tracking is enabled for a client, all the read only queries are assumed
      to be cached: this will force Redis to store information in the invalidation
      table. When keys are modified, such information is flushed away, and
      invalidation messages are sent to the clients. However if the workload is
      heavily dominated by reads, Redis could use more and more memory in order
      to track the keys fetched by many clients.

      For this reason it is possible to configure a maximum fill value for the
      invalidation table. By default it is set to 1M of keys, and once this limit
      is reached, Redis will start to evict keys in the invalidation table
      even if they were not modified, just to reclaim memory: this will in turn
      force the clients to invalidate the cached values. Basically the table
      maximum size is a trade off between the memory you want to spend server
      side to track information about who cached what, and the ability of clients
      to retain cached objects in memory.

      If you set the value to 0, it means there are no limits, and Redis will
      retain as many keys as needed in the invalidation table.
      In the "stats" INFO section, you can find information about the number of
      keys in the invalidation table at every given moment.

      Note: when key tracking is used in broadcasting mode, no memory is used
      in the server side so this setting is useless.
################################## SECURITY ###################################
  acllog_max_len:
    default: "128"
    description: |
      The ACL Log tracks failed commands and authentication events associated
      with ACLs. The ACL Log is useful to troubleshoot failed commands blocked 
      by ACLs. The ACL Log is stored in memory. You can reclaim memory with 
      ACL LOG RESET.
  password:
    description: |
      Password for "default" user.
      Require clients to issue AUTH <PASSWORD> before processing any other commands.  This might be useful in environments in which you do not trust others with access to the host running redis-server.
      This should stay commented out for backward compatibility and because most people do not need auth (e.g. they run their own servers).
      Warning: since Redis is pretty fast an outside user can try up to 150k passwords per second against a good box. This means that you should use a very strong password otherwise it will be very easy to break.
    type: password
  admin_user:
    default: "admin"
    description: |
      Name of the administrator user.
  admin_password:
    description: |
      Password for admin_user.
    type: password
  exporter_user:
    default: "exporter-user"
    description: |
      Name of the exporter user.
  exporter_password:
    description: |
      Password for exporter_user.
    type: password
  replica_user:
    default: "replica-user"
    description: |
      Name of the user for replication.
      If you are using Redis ACLs (for Redis version
      6 or greater), and the default user is not capable of running the PSYNC
      command and/or other commands needed for replication. In this case it's
      better to configure a special user to use with replication.
  replica_password:
    description: |
      Password for replication_user.
    type: password
  sentinel_user:
    default: "sentinel-user"
    description: |
      Name of the user used by Sentinel.
  sentinel_password:
    description: |
      Password for sentinel_user.
    type: password
################################### CLIENTS ####################################
  maxclients:
    default: "10000"
    description: |
      Set the max number of connected clients at the same time. By default this limit is set to 10000 clients, however if the Redis server is not able to configure the process file limit to allow for the specified limit the max number of allowed clients is set to the current file limit minus 32 (as Redis reserves a few file descriptors for internal uses).
      Once the limit is reached Redis will close all the new connections sending an error max number of clients reached."
############################## MEMORY MANAGEMENT ################################
  maxmemory:
    default: "0"
    description: |
      The maxmemory configuration directive is used in order to configure Redis to use a specified amount of memory for the data set. It is possible to set the configuration directive using the redis.conf file, or later using the CONFIG SET command at runtime.

      For example in order to configure a memory limit of 100 megabytes, the following directive can be used inside the redis.conf file.

        maxmemory 100mb

      Setting maxmemory to zero results into no memory limits. This is the default behavior for 64 bit systems, while 32 bit systems use an implicit memory limit of 3GB. Setting maxmemory to zero, when memory runs out the operating system's virtual memory starts to get used up (i.e. swap), and performance drops tremendously. Note: Since Redis 2.0, Redis has a Virtual Memory feature; Redis Virtual Memory is deprecated since 2.4. Look at "Virtual Memory": https://redis.io/topics/virtual-memory.

      When the specified amount of memory is reached, it is possible to select among different behaviors, called policies. Redis can just return errors for commands that could result in more memory being used, or it can evict some old data in order to return back to the specified limit every time new data is added.
  maxmemory_policy:
    default: "noeviction"
    description: |
      maxmemory_policy: how Redis will select what to remove when maxmemory
      is reached. You can select among five behaviors:

        - volatile-lru -> Evict using approximated LRU among the keys with an expire set.
        - allkeys-lru -> Evict any key using approximated LRU.
        - volatile-lfu -> Evict using approximated LFU among the keys with an expire set.
        - allkeys-lfu -> Evict any key using approximated LFU.
        - volatile-random -> Remove a random key among the ones with an expire set.
        - allkeys-random -> Remove a random key, any key.
        - volatile-ttl -> Remove the key with the nearest expire time (minor TTL)
        - noeviction -> Don't evict anything, just return an error on write operations.

      LRU means Least Recently Used
      LFU means Least Frequently Used

      Both LRU, LFU and volatile-ttl are implemented using approximated
      randomized algorithms.

      Note: with any of the above policies, Redis will return an error on write
      operations, when there are no suitable keys for eviction.
  maxmemory_samples:
    default: "5"
    description: |
      LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
      algorithms (in order to save memory), so you can tune it for speed or
      accuracy. For default Redis will check five keys and pick the one that was
      used less recently.

      The default of 5 produces good enough results. 10 Approximates very closely
      true LRU but costs more CPU. 3 is faster but not very accurate.
  replica_ignore_maxmemory:
    default: "yes"
    description: |
      Starting from Redis 5, by default a replica will ignore its maxmemory setting
      (unless it is promoted to master after a failover or manually). It means
      that the eviction of keys will be just handled by the master, sending the
      DEL commands to the replica as keys evict in the master side.

      This behavior ensures that masters and replicas stay consistent, and is usually
      what you want, however if your replica is writable, or you want the replica to have
      a different memory setting, and you are sure all the writes performed to the
      replica are idempotent, then you may change this default (but be sure to understand
      what you are doing).

      Note that since the replica by default does not evict, it may end using more
      memory than the one set via maxmemory (there are certain buffers that may
      be larger on the replica, or data structures may sometimes take more memory and so
      forth). So make sure you monitor your replicas and make sure they have enough
      memory to never hit a real out-of-memory condition before the master hits
      the configured maxmemory setting.
  active_expire_effort:
    default: "1"
    description: |
      Redis reclaims expired keys in two ways: upon access when those keys are
      found to be expired, and also in background, in what is called the
      "active expire key". The key space is slowly and interactively scanned
      looking for expired keys to reclaim, so that it is possible to free memory
      of keys that are expired and will never be accessed again in a short time.
      
      The default effort of the expire cycle will try to avoid having more than
      ten percent of expired keys still in memory, and will try to avoid consuming
      more than 25% of total memory and to add latency to the system. However
      it is possible to increase the expire "effort" that is normally set to
      "1", to a greater value, up to the value "10". At its maximum value the
      system will use more CPU, longer cycles (and technically may introduce
      more latency), and will tollerate less already expired keys still present
      in the system. It's a tradeoff betweeen memory, CPU and latecy.
  lfu_log_factor:
    default: "10"
    description: |
      If LFU eviction is used, lfu_log_factor changes how many hits are needed in order to saturate
      the frequency counter, which is just in the range 0-255. The higher the factor,
      the more accesses are needed in order to reach the maximum. The lower the factor,
      the better is the resolution of the counter for low accesses.
  lfu_decay_time:
    default: "1"
    description: |
      If LFU eviction is used, lfu_decay_time is the amount of minutes a counter should be decayed,
      when sampled and found to be older than that value. A special value of 0 means: always
      decay the counter every time is scanned, and is rarely useful.
################################ THREADED I/O #################################
  io_threads:
    default: "1"
    description: |
      Redis is mostly single threaded, however there are certain threaded
      operations such as UNLINK, slow I/O accesses and other things that are
      performed on side threads.

      Now it is also possible to handle Redis clients socket reads and writes
      in different I/O threads. Since especially writing is so slow, normally
      Redis users use pipelining in order to speedup the Redis performances per
      core, and spawn multiple instances in order to scale more. Using I/O
      threads it is possible to easily speedup two times Redis without resorting
      to pipelining nor sharding of the instance.

      By default threading is disabled, we suggest enabling it only in machines
      that have at least 4 or more cores, leaving at least one spare core.
      Using more than 8 threads is unlikely to help much. We also recommend using
      threaded I/O only if you actually have performance problems, with Redis
      instances being able to use a quite big percentage of CPU time, otherwise
      there is no point in using this feature.

      So for instance if you have a four cores boxes, try to use 2 or 3 I/O
      threads, if you have a 8 cores, try to use 6 threads.

      Setting io_threads to 1 will just use the main thread as usually.
  io_threads_do_reads:
    default: "no"
    description: |
      When I/O threads are enabled, we only use threads for writes, that is
      to thread the write(2) syscall and transfer the client buffers to the
      socket. However it is also possible to enable threading of reads and
      protocol parsing using by setting io_threads_do_reads to yes.

      Usually threading reads doesn't help much.
############################## APPEND ONLY MODE ###############################
  appendonly:
    default: "no"
    description: |
      By default Redis asynchronously dumps the dataset on disk. This mode is good enough in many applications, but an issue with the Redis process or a power outage may result into a few minutes of writes lost (depending on the configured save points).
      The Append Only File is an alternative persistence mode that provides much better durability. For instance using the default data fsync policy (see later in the config file) Redis can lose just one second of writes in a dramatic event like a server power outage, or a single write if something wrong with the Redis process itself happens, but the operating system is still running correctly.
      AOF and RDB persistence can be enabled at the same time without problems.
      If the AOF is enabled on startup Redis will load the AOF, that is the file with the better durability guarantees.
      Please check http://redis.io/topics/persistence for more information.
  appendfsync:
    default: "everysec"
    description: |
      The fsync() call tells the Operating System to actually write data on disk instead of waiting for more data in the output buffer. Some OS will really flush data on disk, some other OS will just try to do it ASAP.
      Redis supports three different modes:
        "no": don't fsync, just let the OS flush the data when it wants. Faster,
        "always": fsync after every write to the append only log. Slow, Safest,
        "everysec": fsync only one time every second. Compromise.
      The default is "everysec", as that's usually the right compromise between speed and data safety. It's up to you to understand if you can relax this to "no" that will let the operating system flush the output buffer when it wants, for better performances (but if you can live with the idea of some data loss consider the default persistence mode that's snapshotting), or on the contrary, use "always" that's very slow but a bit safer than "everysec".
      More details please check the following article:
        http://antirez.com/post/redis-persistence-demystified.html
      If unsure, use "everysec".
  no_appendfsync_on_rewrite:
    default: "no"
    description: |
      When the AOF fsync policy is set to always or everysec, and a background
      saving process (a background save or AOF log background rewriting) is
      performing a lot of I/O against the disk, in some Linux configurations
      Redis may block too long on the fsync() call. Note that there is no fix for
      this currently, as even performing fsync in a different thread will block
      our synchronous write(2) call.

      In order to mitigate this problem it's possible to use the following option
      that will prevent fsync() from being called in the main process while a
      BGSAVE or BGREWRITEAOF is in progress.

      This means that while another child is saving, the durability of Redis is
      the same as "appendfsync none". In practical terms, this means that it is
      possible to lose up to 30 seconds of log in the worst scenario (with the
      default Linux settings).

      If you have latency problems turn this to "yes". Otherwise leave it as
      "no" that is the safest pick from the point of view of durability.
  auto_aof_rewrite_percentage:
    default: "100"
    description: |
      Automatic rewrite of the append only file.
      Redis is able to automatically rewrite the log file implicitly calling
      BGREWRITEAOF when the AOF log size grows by the specified percentage.

      This is how it works: Redis remembers the size of the AOF file after the
      latest rewrite (if no rewrite has happened since the restart, the size of
      the AOF at startup is used).

      This base size is compared to the current size. If the current size is
      bigger than the specified percentage, the rewrite is triggered. Also
      you need to specify a minimal size for the AOF file to be rewritten, this
      is useful to avoid rewriting the AOF file even if the percentage increase
      is reached but it is still pretty small.

      Specify a percentage of zero in order to disable the automatic AOF
      rewrite feature.
  auto_aof_rewrite_min_size:
    default: "64m"
    description: |
      See above auto_aof_rewrite_percentage.
  aof_load_truncated:
    default: "yes"
    description: |
      An AOF file may be found to be truncated at the end during the Redis
      startup process, when the AOF data gets loaded back into memory.
      This may happen when the system where Redis is running
      crashes, especially when an ext4 filesystem is mounted without the
      data=ordered option (however this can't happen when Redis itself
      crashes or aborts but the operating system still works correctly).

      Redis can either exit with an error when this happens, or load as much
      data as possible (the default now) and start if the AOF file is found
      to be truncated at the end. The following option controls this behavior.

      If aof_load_truncated is set to yes, a truncated AOF file is loaded and
      the Redis server starts emitting a log to inform the user of the event.
      Otherwise if the option is set to no, the server aborts with an error
      and refuses to start. When the option is set to no, the user requires
      to fix the AOF file using the "redis-check-aof" utility before to restart
      the server.

      Note that if the AOF file will be found to be corrupted in the middle
      the server will still exit with an error. This option only applies when
      Redis will try to read more data from the AOF file but not enough bytes
      will be found.
  aof_use_rdb_preamble:
    default: "yes"
    description: |
      When rewriting the AOF file, Redis is able to use an RDB preamble in the
      AOF file for faster rewrites and recoveries. When this option is turned
      on the rewritten AOF file is composed of two different stanzas:

        [RDB file][AOF tail]

      When loading Redis recognizes that the AOF file starts with the "REDIS"
      string and loads the prefixed RDB file, and continues loading the AOF
      tail.
################################ LUA SCRIPTING  ###############################
  lua_time_limit:
    default: "5000"
    description: |
      Max execution time of a Lua script in milliseconds.
################################ REDIS CLUSTER  ###############################
  cluster_enabled:
    default: "no"
    description: |
      If "yes" enables Redis Cluster support in a specific Redis instance. Otherwise the instance starts as a stand alone instance as usual.
  cluster_node_timeout:
    default: "15000"
    description: |
      The maximum amount of time a Redis Cluster node can be unavailable, without it being considered as failing. If a master node is not reachable for more than the specified amount of time, it will be failed over by its slaves. This parameter controls other important things in Redis Cluster. Notably, every node that can not reach the majority of master nodes for the specified amount of time, will stop accepting queries.
  cluster_replicas_per_node:
    default: "0"
    description: |
      Number of replicas per cluster's node.
  cluster_replica_validity_factor:
    default: "10"
    description: |
      A replica of a failing master will avoid to start a failover if its data looks too old.
      There is no simple way for a replica to actually have an exact measure of its "data age", so the following two checks are performed:
        1) If there are multiple replicas able to failover, they exchange messages in order to try to give an advantage to the replica with the best replication offset (more data from the master processed). Replicas will try to get their rank by offset, and apply to the start of the failover a delay proportional to their rank.
        2) Every single replica computes the time of the last interaction with its master. This can be the last ping or command received (if the master is still in the "connected" state), or the time that elapsed since the disconnection with the master (if the replication link is currently down). If the last interaction is too old, the replica will not try to failover at all.
      The point "2" can be tuned by user. Specifically a replica will not perform the failover if, since the last interaction with the master, the time elapsed is greater than:
        (node-timeout * replica-validity-factor) + repl-ping-replica-period
      So for example if node-timeout is 30 seconds, and the replica-validity-factor is 10, and assuming a default repl-ping-replica-period of 10 seconds, the replica will not try to failover if it was not able to talk with the master for longer than 310 seconds.
      A large replica-validity-factor may allow replicas with too old data to failover a master, while a too small value may prevent the cluster from being able to elect a replica at all.
      For maximum availability, it is possible to set the replica-validity-factor to a value of 0, which means, that replicas will always try to failover the master regardless of the last time they interacted with the master. (However they'll always try to apply a delay proportional to their offset rank).
      Zero is the only value able to guarantee that when all the partitions heal the cluster will always be able to continue.
  cluster_migration_barrier:
    default: "1"
    description: |
      Cluster replicas are able to migrate to orphaned masters, that are masters that are left without working replicas. This improves the cluster ability to resist to failures as otherwise an orphaned master can't be failed over in case of failure if it has no working replicas.
      Replicas migrate to orphaned masters only if there are still at least a given number of other working replicas for their old master. This number is the "migration barrier". A migration barrier of 1 means that a replica will migrate only if there is at least 1 other working replica for its master and so forth. It usually reflects the number of replicas you want for every master in your cluster.
      Default is 1 (replicas migrate only if their masters remain with at least one replica). To disable migration just set it to a very large value.
      A value of 0 can be set but is useful only for debugging and dangerous in production.
  cluster_require_full_coverage:
    default: "yes"
    description: |
      If this is set to "yes", as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.
  cluster_replica_no_failover:
    default: "no"
    description: |
      This option, when set to yes, prevents replicas from trying to failover its
      master during master failures. However the master can still perform a
      manual failover, if forced to do so.

      This is useful in different scenarios, especially in the case of multiple
      data center operations, where we want one side to never be promoted if not
      in the case of a total DC failure.
  cluster_announce:
    default: false
    description: |
      In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).
      In order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:
        - cluster-announce-ip
        - cluster-announce-port
        - cluster-announce-bus-port
      Each instruct the node about its address, client port, and cluster message bus port. The information is then published in the header of the bus packets so that other nodes will be able to correctly map the address of the node publishing the information.
      If the above options are not used, the normal Redis Cluster auto-detection will be used instead.
      Note that when remapped, the bus port may not be at the fixed offset of clients port + 10000, so you can specify any port and bus-port depending on how they get remapped. If the bus-port is not set, a fixed offset of 10000 will be used as usually.
################################## SLOW LOG ###################################
  slowlog_log_slower_than:
    default: "10000"
    description: |
      The execution time, in microseconds, to exceed in order for the command to get logged. Time is expressed in microseconds, so 1000000 is equivalent to one second. Note that a negative number disables the slow log, while a value of zero forces the logging of every command.
  slowlog_max_len:
    default: "128"
    description: |
      The length of the slow log. There is no limit to this length. Just be aware that it will consume memory. You can reclaim memory used by the slow log with SLOWLOG RESET.
################################ LATENCY MONITOR ##############################
  latency_monitor_threshold:
    default: "0"
    description: |
      The Redis latency monitoring subsystem samples different operations
      at runtime in order to collect data related to possible sources of
      latency of a Redis instance.
      
      Via the LATENCY command this information is available to the user that can
      print graphs and obtain reports.
      
      The system only logs operations that were performed in a time equal or
      greater than the amount of milliseconds specified via the
      latency-monitor-threshold configuration directive. When its value is set
      to zero, the latency monitor is turned off.
      
      By default latency monitoring is disabled since it is mostly not needed
      if you don't have latency issues, and collecting data has a performance
      impact, that while very small, can be measured under big load. Latency
      monitoring can easily be enabled at runtime using the command
      "CONFIG SET latency-monitor-threshold <milliseconds>" if needed.
############################# EVENT NOTIFICATION ##############################
  notify_keyspace_events:
    default: ""
    description: |
      The notify_keyspace_events takes as argument a string that is composed
      of zero or multiple characters. The empty string means that notifications
      are disabled.
      
      Example: to enable list and generic events, from the point of view of the
               event name, use:
      
      notify-keyspace-events Elg
      
      Example 2: to get the stream of the expired keys subscribing to channel
                 name __keyevent@0__:expired use:
      
      notify-keyspace-events Ex
############################### GOPHER SERVER #################################
  gopher_enabled:
    default: "no"
    description: |
      To enable Gopher support set gopher_enabled to yes.